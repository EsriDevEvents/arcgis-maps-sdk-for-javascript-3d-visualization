import{s as F,b as W,a as _}from"./Error-5cdd6e0a.js";import{t as B,r as E}from"./typedArrayUtil-bf9f210a.js";import{m as I,v as P}from"./Polyline-82cb63bc.js";import{r as A,o as j,i as R,s as k}from"./normalizeUtilsCommon-d8ea404e.js";import{i as G,b as M,C as H}from"./Extent-22afa84a.js";import"./geometry-7d866d3f.js";import{L as T,U as X}from"./request-09e7d9b2.js";import{c as z,v as K,d as Q}from"./jsonUtils-36bf3d33.js";import{p as V}from"./string-53224faa.js";function $t(t,s){return s?{...s,query:{...t??{},...s.query}}:{query:t}}function Y(t){return typeof t=="string"?T(t):V(t)}function Z(t,s,u){const n={};for(const e in t){if(e==="declaredClass")continue;const o=t[e];if(o!=null&&typeof o!="function")if(Array.isArray(o)){n[e]=[];for(let r=0;r<o.length;r++)n[e][r]=Z(o[r])}else if(typeof o=="object")if(o.toJSON){const r=o.toJSON(u&&u[e]);n[e]=s?r:JSON.stringify(r)}else n[e]=s?o:JSON.stringify(o);else n[e]=o}return n}async function tt(t,s,u,n){const e=Y(t),o=s[0].spatialReference,r={...n,query:{...e.query,f:"json",sr:JSON.stringify(o),target:JSON.stringify({geometryType:z(s[0]),geometries:s}),cutter:JSON.stringify(u)}},i=await X(e.path+"/cut",r),{cutIndexes:l,geometries:y=[]}=i.data;return{cutIndexes:l,geometries:y.map(h=>{const d=K(h);return d.spatialReference=o,d})}}function et(t){return{geometryType:z(t[0]),geometries:t.map(s=>s.toJSON())}}function st(t,s,u){const n=Q(s);return t.map(e=>{const o=n.fromJSON(e);return o.spatialReference=u,o})}async function nt(t,s,u){const n=typeof t=="string"?T(t):t,e=s[0].spatialReference,o=z(s[0]),r={...u,query:{...n.query,f:"json",sr:e.wkid?e.wkid:JSON.stringify(e),geometries:JSON.stringify(et(s))}},{data:i}=await X(n.path+"/simplify",r);return st(i.geometries,o,e)}const D=F.getLogger("esri.geometry.support.normalizeUtils");function ot(t){return t.type==="polygon"}function rt(t){return t[0].type==="polygon"}function it(t){return t[0].type==="polyline"}function ft(t,s){if(!(t instanceof I||t instanceof P)){const e="straightLineDensify: the input geometry is neither polyline nor polygon";throw D.error(e),new _(e)}const u=j(t),n=[];for(const e of u){const o=[];n.push(o),o.push([e[0][0],e[0][1]]);for(let r=0;r<e.length-1;r++){const i=e[r][0],l=e[r][1],y=e[r+1][0],h=e[r+1][1],d=Math.sqrt((y-i)*(y-i)+(h-l)*(h-l)),a=(h-l)/d,m=(y-i)/d,p=d/s;if(p>1){for(let S=1;S<=p-1;S++){const N=S*s,f=m*N+i,c=a*N+l;o.push([f,c])}const w=(d+Math.floor(p-1)*s)/2,J=m*w+i,v=a*w+l;o.push([J,v])}o.push([y,h])}}return ot(t)?new P({rings:n,spatialReference:t.spatialReference}):new I({paths:n,spatialReference:t.spatialReference})}function C(t,s,u){if(s){const n=ft(t,1e6);t=H(n,!0)}return u&&(t=k(t,u)),t}function U(t,s,u){if(Array.isArray(t)){const n=t[0];if(n>s){const e=R(n,s);t[0]=n+e*(-2*s)}else if(n<u){const e=R(n,u);t[0]=n+e*(-2*u)}}else{const n=t.x;if(n>s){const e=R(n,s);t=t.clone().offset(e*(-2*s),0)}else if(n<u){const e=R(n,u);t=t.clone().offset(e*(-2*u),0)}}return t}function ct(t,s){let u=-1;for(let n=0;n<s.cutIndexes.length;n++){const e=s.cutIndexes[n],o=s.geometries[n],r=j(o);for(let i=0;i<r.length;i++){const l=r[i];l.some(y=>{if(y[0]<180)return!0;{let h=0;for(let a=0;a<l.length;a++){const m=l[a][0];h=m>h?m:h}h=Number(h.toFixed(9));const d=-360*R(h,180);for(let a=0;a<l.length;a++){const m=o.getPoint(i,a);o.setPoint(i,a,m.clone().offset(d,0))}return!0}})}if(e===u){if(rt(t))for(const i of j(o))t[e]=t[e].addRing(i);else if(it(t))for(const i of j(o))t[e]=t[e].addPath(i)}else u=e,t[e]=o}return t}async function ut(t,s,u){if(!Array.isArray(t))return ut([t],s);s&&typeof s!="string"&&D.warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const n=typeof s=="string"?s:(s==null?void 0:s.url)??W.geometryServiceUrl;let e,o,r,i,l,y,h,d,a=0;const m=[],p=[];for(const f of t)if(B(f))p.push(f);else if(e||(e=f.spatialReference,o=G(e),r=e.isWebMercator,y=r?102100:4326,i=A[y].maxX,l=A[y].minX,h=A[y].plus180Line,d=A[y].minus180Line),o)if(f.type==="mesh")p.push(f);else if(f.type==="point")p.push(U(f.clone(),i,l));else if(f.type==="multipoint"){const c=f.clone();c.points=c.points.map(g=>U(g,i,l)),p.push(c)}else if(f.type==="extent"){const c=f.clone()._normalize(!1,!1,o);p.push(c.rings?new P(c):c)}else if(f.extent){const c=f.extent,g=R(c.xmin,l)*(2*i);let x=g===0?f.clone():k(f.clone(),g);c.offset(g,0),c.intersects(h)&&c.xmax!==i?(a=c.xmax>a?c.xmax:a,x=C(x,r),m.push(x),p.push("cut")):c.intersects(d)&&c.xmin!==l?(a=c.xmax*(2*i)>a?c.xmax*(2*i):a,x=C(x,r,360),m.push(x),p.push("cut")):p.push(x)}else p.push(f.clone());else p.push(f);let w=R(a,i),J=-90;const v=w,S=new I;for(;w>0;){const f=360*w-180;S.addPath([[f,J],[f,-1*J]]),J*=-1,w--}if(m.length>0&&v>0){const f=ct(m,await tt(n,m,S,u)),c=[],g=[];for(let $=0;$<p.length;$++){const O=p[$];if(O!=="cut")g.push(O);else{const b=f.shift(),q=t[$];E(q)&&q.type==="polygon"&&q.rings&&q.rings.length>1&&b.rings.length>=q.rings.length?(c.push(b),g.push("simplify")):g.push(r?M(b):b)}}if(!c.length)return g;const x=await nt(n,c,u),L=[];for(let $=0;$<g.length;$++){const O=g[$];O!=="simplify"?L.push(O):L.push(r?M(x.shift()):x.shift())}return L}const N=[];for(let f=0;f<p.length;f++){const c=p[f];if(c!=="cut")N.push(c);else{const g=m.shift();N.push(r===!0?M(g):g)}}return N}export{Y as f,$t as i,st as o,Z as s,ut as v};
